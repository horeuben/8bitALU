module state (
    input clk,  // clock
    input rst,  // reset
    input dipsw,
    input alufn[6], //only using 0:5 //get from  io_dip[2]
    input a[8],
    input b[8],
    output out[8], //result of a <some operation> b
    output z,
    output v,
    output n ,
    output clk_a[8],
    output clk_b[8]
  ) {

  .clk(clk) {
    .rst(rst) {
      fsm state = {MANUAL,AUTO};
      counter autoab (#SIZE(16),#DIV(24)); //first 8 bits b(15:8), last 8 bits a (7:0)
      
    }
    
  }
  alu myalu;
  
  always {
    out = 0;
    z = 0;
    v = 0;
    n = 0;
    myalu.alufn = alufn;
    myalu.a = 0;
    myalu.b = 0;
    clk_a = 0;
    clk_b = 0;
    case (state.q){
      state.MANUAL:
        myalu.a = a;
        myalu.b = b;
        myalu.alufn = alufn;
        out = myalu.alu;
        z = myalu.z;
        v = myalu.v;
        n = myalu.n;
        clk_a = a;
        clk_b = b;
        if(dipsw){
          state.d = state.AUTO;
        }
       
      state.AUTO:
        myalu.alufn = alufn;
        myalu.b = autoab.value[15:8];
        myalu.a = autoab.value[7:0];
        clk_b = autoab.value[15:8];
        clk_a = autoab.value[7:0];
        out = myalu.alu;
        z = myalu.z;
        v = myalu.v;
        n = myalu.n;
        if (!dipsw){
          state.d = state.MANUAL;
        }
    }
  }
}